
module Core_Ops_Function_FnOnce_Output_Type
  type self
  type args
  type output
end
module CreusotContracts_Std1_Ops_FnExt_Postcondition_Stub
  type self
  type args
  use prelude.Bool
  clone Core_Ops_Function_FnOnce_Output_Type as Output0 with
    type self = self,
    type args = args
  predicate postcondition (self : self) (_2' : args) (_3' : Output0.output)
end
module CreusotContracts_Std1_Ops_FnExt_Postcondition
  type self
  type args
  use prelude.Bool
  clone Core_Ops_Function_FnOnce_Output_Type as Output0 with
    type self = self,
    type args = args
  predicate postcondition (self : self) (_2' : args) (_3' : Output0.output)
  val postcondition (self : self) (_2' : args) (_3' : Output0.output) : bool
    ensures { result = postcondition self _2' _3' }
    
end
module CreusotContracts_Std1_Ops_Impl2_Postcondition_Stub
  type args
  type f
  use prelude.Bool
  clone Core_Ops_Function_FnOnce_Output_Type as Output1 with
    type self = f,
    type args = args
  predicate postcondition (self : f) (_2' : args) (_3' : Output1.output)
end
module CreusotContracts_Std1_Ops_Impl2_Postcondition
  type args
  type f
  use prelude.Bool
  clone Core_Ops_Function_FnOnce_Output_Type as Output1 with
    type self = f,
    type args = args
  predicate postcondition (self : f) (_2' : args) (_3' : Output1.output)
  val postcondition (self : f) (_2' : args) (_3' : Output1.output) : bool
    ensures { result = postcondition self _2' _3' }
    
end
module CreusotContracts_Std1_Ops_Impl0_Precondition_Stub
  type args
  type f
  use prelude.Bool
  predicate precondition (self : f) (_2' : args)
end
module CreusotContracts_Std1_Ops_Impl0_Precondition
  type args
  type f
  use prelude.Bool
  predicate precondition (self : f) (_2' : args)
  val precondition (self : f) (_2' : args) : bool
    ensures { result = precondition self _2' }
    
end
module Core_Ops_Function_Fn_Call_Stub
  type self
  type args
  use prelude.Bool
  clone Core_Ops_Function_FnOnce_Output_Type as Output0 with
    type self = self,
    type args = args
  clone CreusotContracts_Std1_Ops_FnExt_Postcondition_Stub as Postcondition0 with
    type self = self,
    type args = args,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Ops_Impl0_Precondition_Stub as Precondition1 with
    type args = args,
    type f = self
  val call [@cfg:stackify] (self : self) (args : args) : Output0.output
    requires {Precondition1.precondition self args}
    ensures { Postcondition0.postcondition self args result }
    
end
module C05Map_Map_Type
  type t_map 'i 'f =
    | C_Map 'i 'f
    
end
module C05Map_Map_Func_Stub
  type i
  type f
  use C05Map_Map_Type as CMap0
  val function field_func [#"../05_map.rs" 11 4 11 11] (self : CMap0.t_map i f) : f
end
module C05Map_Map_Func
  type i
  type f
  use C05Map_Map_Type as CMap0
  let function field_func [#"../05_map.rs" 11 4 11 11] (self : CMap0.t_map i f) : f = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../05_map.rs" 1 0 1 0] match (self) with
      | CMap0.C_Map _ a -> a
      end
end
module C05Map_FakeIterator_Item_Type
  type self
  type item
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module Core_Option_Option_Some_0_Stub
  type t
  use Core_Option_Option_Type as TOption0
  val function field_0 (self : TOption0.t_option t) : t
end
module Core_Option_Option_Some_0
  type t
  use Core_Option_Option_Type as TOption0
  let function field_0 (self : TOption0.t_option t) : t = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../05_map.rs" 1 0 1 0] match (self) with
      | TOption0.C_None -> any t
      | TOption0.C_Some a -> a
      end
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  use prelude.Bool
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  use prelude.Bool
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Bool
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Opaque
  use mach.int.Int
  use prelude.Bool
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
     ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module C05Map_FakeIterator_Next_Stub
  type self
  use Core_Option_Option_Type as TOption1
  use prelude.Borrow
  clone C05Map_FakeIterator_Item_Type as Item0 with
    type self = self
  val next [@cfg:stackify] [#"../05_map.rs" 6 4 6 45] (self : borrowed self) : TOption1.t_option Item0.item
end
module C05Map_Map_Iter_Stub
  type i
  type f
  use C05Map_Map_Type as CMap0
  val function field_iter [#"../05_map.rs" 10 4 10 11] (self : CMap0.t_map i f) : i
end
module C05Map_Map_Iter
  type i
  type f
  use C05Map_Map_Type as CMap0
  let function field_iter [#"../05_map.rs" 10 4 10 11] (self : CMap0.t_map i f) : i = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../05_map.rs" 1 0 1 0] match (self) with
      | CMap0.C_Map a _ -> a
      end
end
module C05Map_Impl0_Next_Stub
  type a
  type b
  type f
  type i
  use prelude.Bool
  use C05Map_Map_Type as CMap1
  use Core_Option_Option_Type as TOption1
  use prelude.Borrow
  use Core_Option_Option_Type as TOption3
  clone CreusotContracts_Std1_Ops_Impl2_Postcondition_Stub as Postcondition1 with
    type args = a,
    type f = f,
    type Output1.output = b
  clone CreusotContracts_Std1_Ops_Impl0_Precondition_Stub as Precondition1 with
    type args = a,
    type f = f
  val next [@cfg:stackify] [#"../05_map.rs" 17 4 17 44] (self : borrowed (CMap1.t_map i f)) : TOption3.t_option b
end
module C05Map_Impl0_Next
  type a
  type b
  type f
  type i
  use prelude.Bool
  use C05Map_Map_Type as CMap1
  use Core_Option_Option_Type as TOption1
  use prelude.Opaque
  use mach.int.Int
  use prelude.Borrow
  use prelude.IntSize
  use Core_Option_Option_Type as TOption3
  clone CreusotContracts_Std1_Ops_Impl2_Postcondition as Postcondition1 with
    type args = a,
    type f = f,
    type Output1.output = b
  clone CreusotContracts_Std1_Ops_Impl0_Precondition as Precondition1 with
    type args = a,
    type f = f
  clone Core_Ops_Function_Fn_Call_Stub as Call1 with
    type self = f,
    type args = a,
    predicate Precondition1.precondition = Precondition1.precondition,
    predicate Postcondition0.postcondition = Postcondition1.postcondition,
    type Output0.output = b
  clone C05Map_Map_Func as FieldFunc1 with
    type i = i,
    type f = f
  clone Core_Option_Option_Some_0 as Field01 with
    type t = a
  clone CreusotContracts_Resolve_Resolve_Resolve as Resolve1 with
    type self = a
  clone CreusotContracts_Resolve_Resolve_Resolve as Resolve2 with
    type self = TOption1.t_option a
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve4 with
    type t = CMap1.t_map i f
  clone C05Map_FakeIterator_Next_Stub as Next1 with
    type self = i,
    type Item0.item = a
  clone C05Map_Map_Iter as FieldIter1 with
    type i = i,
    type f = f
  let rec cfg next [@cfg:stackify] [#"../05_map.rs" 17 4 17 44] (self : borrowed (CMap1.t_map i f)) : TOption3.t_option b
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : TOption3.t_option b;
  var self_1 : borrowed (CMap1.t_map i f);
  var _2 : TOption1.t_option a;
  var _3 : borrowed i;
  var _4 : isize;
  var e_5 : a;
  var _6 : b;
  var _7 : f;
  var _8 : a;
  var _9 : a;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _3 <- borrow_mut (FieldIter1.field_iter ( * self_1));
    self_1 <- { self_1 with current = (let CMap1.C_Map a b =  * self_1 in CMap1.C_Map ( ^ _3) b) };
    _2 <- ([#"../05_map.rs" 18 14 18 30] Next1.next _3);
    goto BB1
  }
  BB1 {
    switch (_2)
      | TOption1.C_None -> goto BB4
      | TOption1.C_Some _ -> goto BB2
      end
  }
  BB2 {
    assume { Resolve1.resolve e_5 };
    e_5 <- Field01.field_0 _2;
    _2 <- (let TOption1.C_Some a = _2 in TOption1.C_Some (any a));
    _7 <- FieldFunc1.field_func ( * self_1);
    assume { Resolve4.resolve self_1 };
    assume { Resolve1.resolve _9 };
    _9 <- e_5;
    e_5 <- any a;
    _8 <- (_9);
    _6 <- ([#"../05_map.rs" 20 28 20 42] Call1.call _7 _8);
    goto BB5
  }
  BB3 {
    assume { Resolve4.resolve self_1 };
    assume { Resolve2.resolve _2 };
    absurd
  }
  BB4 {
    assume { Resolve4.resolve self_1 };
    _0 <- TOption3.C_None;
    goto BB9
  }
  BB5 {
    goto BB6
  }
  BB6 {
    _0 <- TOption3.C_Some _6;
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    assume { Resolve2.resolve _2 };
    return _0
  }
  
end
module C05Map_Impl0
  
end
