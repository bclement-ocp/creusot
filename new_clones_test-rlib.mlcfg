
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module CreusotContracts_Logic_Seq_Impl1_Index_Stub
  type t
  use mach.int.Int
  use seq.Seq
  function index (self : Seq.seq t) (_2' : int) : t
end
module CreusotContracts_Logic_Seq_Impl1_Index
  type t
  use mach.int.Int
  use seq.Seq
  use seq.Seq
  function index (self : Seq.seq t) (_2' : int) : t =
    Seq.get self _2'
  val index (self : Seq.seq t) (_2' : int) : t
    ensures { result = index self _2' }
    
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  use prelude.Bool
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  use prelude.Bool
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  use prelude.Bool
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  use prelude.Bool
  predicate resolve (self : t) =
    true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as CPhantomData0
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull0
  type t_unique 't =
    | C_Unique (CNonNull0.t_nonnull 't) (CPhantomData0.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.UIntSize
  use Core_Marker_PhantomData_Type as CPhantomData0
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull0
  use Core_Ptr_Unique_Unique_Type as CUnique0
  type t_rawvec 't 'a =
    | C_RawVec (CUnique0.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use Core_Marker_PhantomData_Type as CPhantomData0
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull0
  use Core_Ptr_Unique_Unique_Type as CUnique0
  use Alloc_RawVec_RawVec_Type as CRawVec0
  type t_vec 't 'a =
    | C_Vec (CRawVec0.t_rawvec 't 'a) usize
    
end
module Core_Num_Impl12_Max_Stub
  use prelude.UIntSize
  val constant mAX'  : usize
end
module Core_Num_Impl12_Max
  use prelude.UIntSize
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
end
module CreusotContracts_Logic_Int_Impl17_ShallowModel_Stub
  use mach.int.Int
  use prelude.UIntSize
  function shallow_model (self : usize) : int
end
module CreusotContracts_Logic_Int_Impl17_ShallowModel
  use mach.int.Int
  use prelude.UIntSize
  use mach.int.UInt64
  function shallow_model (self : usize) : int =
    UInt64.to_int self
  val shallow_model (self : usize) : int
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Logic_Seq_Impl0_Len_Stub
  type t
  use mach.int.Int
  use seq.Seq
  function len (self : Seq.seq t) : int
end
module CreusotContracts_Logic_Seq_Impl0_Len
  type t
  use mach.int.Int
  use seq.Seq
  use seq.Seq
  function len (self : Seq.seq t) : int =
    Seq.length self
  val len (self : Seq.seq t) : int
    ensures { result = len self }
    
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub
  type t
  type a
  use prelude.UIntSize
  use prelude.Bool
  use seq.Seq
  use Alloc_Vec_Vec_Type as CVec0
  use mach.int.Int
  use mach.int.UInt64
  use seq.Seq
  clone Core_Num_Impl12_Max_Stub as MAx0
  function shallow_model (self : CVec0.t_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel
  type t
  type a
  use prelude.UIntSize
  use prelude.Bool
  use Core_Marker_PhantomData_Type as CPhantomData0
  use seq.Seq
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull0
  use Core_Ptr_Unique_Unique_Type as CUnique0
  use Alloc_RawVec_RawVec_Type as CRawVec0
  use Alloc_Vec_Vec_Type as CVec0
  use prelude.Opaque
  use mach.int.Int
  use mach.int.UInt64
  use seq.Seq
  clone Core_Num_Impl12_Max_Stub as MAx0
  function shallow_model (self : CVec0.t_vec t a) : Seq.seq t
  val shallow_model (self : CVec0.t_vec t a) : Seq.seq t
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : CVec0.t_vec t a . Seq.length (shallow_model self) <= UInt64.to_int MAx0.mAX'
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module CreusotContracts_Std1_Vec_Impl9_Resolve_Stub
  type t
  use mach.int.Int
  use seq.Seq
  use seq.Seq
  use prelude.Bool
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type as CVec1
  use mach.int.UInt64
  use seq.Seq
  use Alloc_Alloc_Global_Type as CGlobal0
  clone Core_Num_Impl12_Max_Stub as MAx0
  predicate resolve (self : CVec1.t_vec t (CGlobal0.t_global))
end
module CreusotContracts_Std1_Vec_Impl9_Resolve
  type t
  use prelude.Opaque
  use mach.int.Int
  use Core_Marker_PhantomData_Type as CPhantomData0
  use seq.Seq
  use seq.Seq
  use prelude.Bool
  use prelude.UIntSize
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull0
  use Core_Ptr_Unique_Unique_Type as CUnique0
  use Alloc_RawVec_RawVec_Type as CRawVec1
  use Alloc_Vec_Vec_Type as CVec1
  use mach.int.UInt64
  use seq.Seq
  use Alloc_Alloc_Global_Type as CGlobal0
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = t
  clone Core_Num_Impl12_Max_Stub as MAx0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel3 with
    type t = t,
    type a = CGlobal0.t_global
  predicate resolve (self : CVec1.t_vec t (CGlobal0.t_global)) =
    forall i : int . 0 <= i /\ i < Seq.length (ShallowModel3.shallow_model self) -> Resolve1.resolve (Seq.get (ShallowModel3.shallow_model self) i)
  val resolve (self : CVec1.t_vec t (CGlobal0.t_global)) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Std1_Iter_FromIterator_FromIterPost_Stub
  type self
  type a
  use prelude.Bool
  use seq.Seq
  predicate from_iter_post (prod : Seq.seq a) (res : self)
end
module CreusotContracts_Std1_Iter_FromIterator_FromIterPost
  type self
  type a
  use prelude.Bool
  use Core_Marker_PhantomData_Type as CPhantomData1
  use seq.Seq
  predicate from_iter_post (prod : Seq.seq a) (res : self)
  val from_iter_post (prod : Seq.seq a) (res : self) : bool
    ensures { result = from_iter_post prod res }
    
end
module CreusotContracts_Std1_Vec_Impl8_FromIterPost_Stub
  type t
  use prelude.UIntSize
  use prelude.Bool
  use seq.Seq
  use Alloc_Vec_Vec_Type as CVec1
  use mach.int.Int
  use mach.int.UInt64
  use seq.Seq
  use Alloc_Alloc_Global_Type as CGlobal0
  clone Core_Num_Impl12_Max_Stub as MAx0
  predicate from_iter_post (prod : Seq.seq t) (res : CVec1.t_vec t (CGlobal0.t_global))
end
module CreusotContracts_Std1_Vec_Impl8_FromIterPost
  type t
  use prelude.UIntSize
  use prelude.Bool
  use Core_Marker_PhantomData_Type as CPhantomData0
  use seq.Seq
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull0
  use Core_Ptr_Unique_Unique_Type as CUnique0
  use Alloc_RawVec_RawVec_Type as CRawVec1
  use Alloc_Vec_Vec_Type as CVec1
  use prelude.Opaque
  use mach.int.Int
  use mach.int.UInt64
  use seq.Seq
  use Alloc_Alloc_Global_Type as CGlobal0
  clone Core_Num_Impl12_Max_Stub as MAx0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel3 with
    type t = t,
    type a = CGlobal0.t_global
  predicate from_iter_post (prod : Seq.seq t) (res : CVec1.t_vec t (CGlobal0.t_global)) =
    prod = ShallowModel3.shallow_model res
  val from_iter_post (prod : Seq.seq t) (res : CVec1.t_vec t (CGlobal0.t_global)) : bool
    ensures { result = from_iter_post prod res }
    
end
module Core_Iter_Traits_Iterator_Iterator_Item_Type
  type self
  type item
end
module CreusotContracts_Logic_Seq_Impl0_Subsequence_Stub
  type t
  use mach.int.Int
  use seq.Seq
  function subsequence (self : Seq.seq t) (_2' : int) (_3' : int) : Seq.seq t
end
module CreusotContracts_Logic_Seq_Impl0_Subsequence
  type t
  use mach.int.Int
  use seq.Seq
  use seq_ext.SeqExt
  function subsequence (self : Seq.seq t) (_2' : int) (_3' : int) : Seq.seq t =
    SeqExt.subsequence self _2' _3'
  val subsequence (self : Seq.seq t) (_2' : int) (_3' : int) : Seq.seq t
    ensures { result = subsequence self _2' _3' }
    
end
module CreusotContracts_Ghost_Impl2_New_Stub
  type t
  use prelude.Ghost
  function new (_1' : t) : Ghost.ghost_ty t
end
module CreusotContracts_Ghost_Impl2_New
  type t
  use prelude.Ghost
  use prelude.Ghost
  function new (_1' : t) : Ghost.ghost_ty t =
    Ghost.new _1'
  val new (_1' : t) : Ghost.ghost_ty t
    ensures { result = new _1' }
    
end
module CreusotContracts_Ghost_Impl0_Deref_Stub
  type t
  use prelude.Ghost
  function deref (self : Ghost.ghost_ty t) : t
end
module CreusotContracts_Ghost_Impl0_Deref
  type t
  use prelude.Ghost
  use prelude.Ghost
  function deref (self : Ghost.ghost_ty t) : t =
    Ghost.inner self
  val deref (self : Ghost.ghost_ty t) : t
    ensures { result = deref self }
    
end
module CreusotContracts_Logic_Seq_Impl0_Concat_Stub
  type t
  use seq.Seq
  function concat (self : Seq.seq t) (_2' : Seq.seq t) : Seq.seq t
end
module CreusotContracts_Logic_Seq_Impl0_Concat
  type t
  use seq.Seq
  use seq.Seq
  function concat (self : Seq.seq t) (_2' : Seq.seq t) : Seq.seq t =
    Seq.(++) self _2'
  val concat (self : Seq.seq t) (_2' : Seq.seq t) : Seq.seq t
    ensures { result = concat self _2' }
    
end
module CreusotContracts_Std1_Iter_MapInv_MapInv_Type
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  type t_mapinv 'i 'b 'f =
    | C_MapInv 'i 'f (Ghost.ghost_ty (Seq.seq 'b))
    
end
module CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub
  type i
  type b
  type f
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv0
  val function field_produced (self : CMapInv0.t_mapinv i b f) : Ghost.ghost_ty (Seq.seq b)
end
module CreusotContracts_Std1_Iter_MapInv_MapInv_Produced
  type i
  type b
  type f
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv0
  let function field_produced (self : CMapInv0.t_mapinv i b f) : Ghost.ghost_ty (Seq.seq b)
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] match (self) with
      | CMapInv0.C_MapInv _ _ a -> a
      end
end
module CreusotContracts_Ghost_Impl2_Inner_Stub
  type t
  use prelude.Ghost
  function inner (self : Ghost.ghost_ty t) : t
end
module CreusotContracts_Ghost_Impl2_Inner
  type t
  use prelude.Ghost
  use prelude.Ghost
  function inner (self : Ghost.ghost_ty t) : t =
    Ghost.inner self
  val inner (self : Ghost.ghost_ty t) : t
    ensures { result = inner self }
    
end
module CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub
  type i
  type b
  type f
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv0
  val function field_iter (self : CMapInv0.t_mapinv i b f) : i
end
module CreusotContracts_Std1_Iter_MapInv_MapInv_Iter
  type i
  type b
  type f
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv0
  let function field_iter (self : CMapInv0.t_mapinv i b f) : i = [@vc:do_not_keep_trace] [@vc:sp]
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] match (self) with
      | CMapInv0.C_MapInv a _ _ -> a
      end
end
module Core_Slice_Iter_Iter_Type
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull1
  type t_iter 't =
    | C_Iter (CNonNull1.t_nonnull 't) opaque_ptr (CPhantomData1.t_phantomdata 't)
    
end
module CreusotContracts_Std1_Slice_Impl13_ShallowModel_Stub
  type t
  use Core_Slice_Iter_Iter_Type as CIter0
  function shallow_model (self : CIter0.t_iter t) : seq t
end
module CreusotContracts_Std1_Slice_Impl13_ShallowModel
  type t
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull1
  use Core_Slice_Iter_Iter_Type as CIter0
  function shallow_model (self : CIter0.t_iter t) : seq t
  val shallow_model (self : CIter0.t_iter t) : seq t
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_SliceModel_Stub
  type t
  use seq.Seq
  function slice_model (_1' : seq t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_SliceModel
  type t
  use seq.Seq
  use prelude.Slice
  function slice_model (_1' : seq t) : Seq.seq t =
    Slice.id _1'
  val slice_model (_1' : seq t) : Seq.seq t
    ensures { result = slice_model _1' }
    
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub
  type t
  use prelude.UIntSize
  use prelude.Bool
  use seq.Seq
  use prelude.Slice
  use mach.int.Int
  use mach.int.UInt64
  use seq.Seq
  clone Core_Num_Impl12_Max_Stub as MAx0
  function shallow_model (self : seq t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel
  type t
  use prelude.UIntSize
  use prelude.Bool
  use Core_Marker_PhantomData_Type as CPhantomData0
  use seq.Seq
  use prelude.Slice
  use prelude.Opaque
  use mach.int.Int
  use mach.int.UInt64
  use seq.Seq
  clone Core_Num_Impl12_Max_Stub as MAx0
  function shallow_model (self : seq t) : Seq.seq t
  val shallow_model (self : seq t) : Seq.seq t
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : seq t . shallow_model self = Slice.id self && Seq.length (shallow_model self) <= UInt64.to_int MAx0.mAX'
end
module CreusotContracts_Model_Impl1_ShallowModel_Stub
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy1 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy1.shallowModelTy
end
module CreusotContracts_Model_Impl1_ShallowModel
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy1 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel1 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy1.shallowModelTy =
    ShallowModel1.shallow_model self
  val shallow_model (self : t) : ShallowModelTy1.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_Impl4_ToRefSeq_Stub
  type t
  use seq.Seq
  use prelude.Bool
  use seq.Seq
  use mach.int.Int
  use seq.Seq
  use seq.Seq
  use prelude.UIntSize
  use prelude.Slice
  use mach.int.UInt64
  use seq.Seq
  use seq.Seq
  clone Core_Num_Impl12_Max_Stub as MAx0
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel5 with
    type t = seq t,
    type ShallowModelTy1.shallowModelTy = Seq.seq t
  function to_ref_seq (self : seq t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl4_ToRefSeq
  type t
  use Core_Marker_PhantomData_Type as CPhantomData0
  use seq.Seq
  use prelude.Bool
  use Core_Marker_PhantomData_Type as CPhantomData1
  use seq.Seq
  use prelude.Opaque
  use mach.int.Int
  use seq.Seq
  use seq.Seq
  use prelude.UIntSize
  use prelude.Slice
  use mach.int.UInt64
  use seq.Seq
  use seq.Seq
  clone Core_Num_Impl12_Max_Stub as MAx0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel2 with
    type t = t
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel5 with
    type t = seq t,
    type ShallowModelTy1.shallowModelTy = Seq.seq t
  function to_ref_seq (self : seq t) : Seq.seq t
  val to_ref_seq (self : seq t) : Seq.seq t
    ensures { result = to_ref_seq self }
    
  axiom to_ref_seq_spec : forall self : seq t . (forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self) -> Seq.get (to_ref_seq self) i = Seq.get (ShallowModel5.shallow_model self) i) && Seq.length (to_ref_seq self) = Seq.length (ShallowModel5.shallow_model self)
end
module CreusotContracts_Std1_Iter_Iterator_Produces_Stub
  type self
  use prelude.Bool
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_3' : self)
end
module CreusotContracts_Std1_Iter_Iterator_Produces
  type self
  use prelude.Bool
  use Core_Marker_PhantomData_Type as CPhantomData1
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_3' : self)
  val produces (self : self) (visited : Seq.seq Item0.item) (_3' : self) : bool
    ensures { result = produces self visited _3' }
    
end
module CreusotContracts_Std1_Slice_Impl15_Produces_Stub
  type t
  use seq.Seq
  use Core_Slice_Iter_Iter_Type as CIter0
  use seq.Seq
  use prelude.Bool
  use mach.int.Int
  use seq.Seq
  use seq.Seq
  use prelude.UIntSize
  use prelude.Slice
  use mach.int.UInt64
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl13_ShallowModel_Stub as ShallowModel1 with
    type t = t
  clone Core_Num_Impl12_Max_Stub as MAx0
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel7 with
    type t = seq t,
    type ShallowModelTy1.shallowModelTy = Seq.seq t
  predicate produces (self : CIter0.t_iter t) (visited : Seq.seq t) (tl : CIter0.t_iter t)
end
module CreusotContracts_Std1_Slice_Impl15_Produces
  type t
  use Core_Marker_PhantomData_Type as CPhantomData1
  use seq.Seq
  use seq.Seq
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull1
  use Core_Slice_Iter_Iter_Type as CIter0
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use prelude.Bool
  use prelude.Opaque
  use mach.int.Int
  use seq.Seq
  use seq.Seq
  use prelude.UIntSize
  use prelude.Slice
  use mach.int.UInt64
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl13_ShallowModel_Stub as ShallowModel1 with
    type t = t
  clone Core_Num_Impl12_Max_Stub as MAx0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel4 with
    type t = t
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel7 with
    type t = seq t,
    type ShallowModelTy1.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Slice_Impl4_ToRefSeq_Stub as ToRefSeq1 with
    type t = t
  predicate produces (self : CIter0.t_iter t) (visited : Seq.seq t) (tl : CIter0.t_iter t) =
    ToRefSeq1.to_ref_seq (ShallowModel1.shallow_model self) = Seq.(++) visited (ToRefSeq1.to_ref_seq (ShallowModel1.shallow_model tl))
  val produces (self : CIter0.t_iter t) (visited : Seq.seq t) (tl : CIter0.t_iter t) : bool
    ensures { result = produces self visited tl }
    
end
module CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub
  type i
  type b
  type f
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv0
  val function field_func (self : CMapInv0.t_mapinv i b f) : f
end
module CreusotContracts_Std1_Iter_MapInv_MapInv_Func
  type i
  type b
  type f
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv0
  let function field_func (self : CMapInv0.t_mapinv i b f) : f = [@vc:do_not_keep_trace] [@vc:sp]
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] match (self) with
      | CMapInv0.C_MapInv _ a _ -> a
      end
end
module Core_Ops_Function_FnOnce_Output_Type
  type self
  type args
  type output
end
module CreusotContracts_Std1_Ops_Impl1_PostconditionMut_Stub
  type args
  type f
  use prelude.Bool
  use prelude.Borrow
  clone Core_Ops_Function_FnOnce_Output_Type as Output1 with
    type self = f,
    type args = args
  predicate postcondition_mut (self : borrowed f) (_2' : args) (_3' : Output1.output)
end
module CreusotContracts_Std1_Ops_Impl1_PostconditionMut
  type args
  type f
  use prelude.Bool
  use prelude.Borrow
  clone Core_Ops_Function_FnOnce_Output_Type as Output1 with
    type self = f,
    type args = args
  predicate postcondition_mut (self : borrowed f) (_2' : args) (_3' : Output1.output)
  val postcondition_mut (self : borrowed f) (_2' : args) (_3' : Output1.output) : bool
    ensures { result = postcondition_mut self _2' _3' }
    
end
module CreusotContracts_Std1_Ops_Impl0_Precondition_Stub
  type args
  type f
  use prelude.Bool
  predicate precondition (self : f) (_2' : args)
end
module CreusotContracts_Std1_Ops_Impl0_Precondition
  type args
  type f
  use prelude.Bool
  predicate precondition (self : f) (_2' : args)
  val precondition (self : f) (_2' : args) : bool
    ensures { result = precondition self _2' }
    
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use mach.int.Int
  use prelude.Bool
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Opaque
  use mach.int.Int
  use prelude.Bool
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
     ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Std1_Ops_Impl1_Unnest_Stub
  type args
  type f
  use prelude.Bool
  predicate unnest (self : f) (_2' : f)
end
module CreusotContracts_Std1_Ops_Impl1_Unnest
  type args
  type f
  use prelude.Bool
  predicate unnest (self : f) (_2' : f)
  val unnest (self : f) (_2' : f) : bool
    ensures { result = unnest self _2' }
    
end
module NewClonesTest_Counter_Closure0_Stub
  use mach.int.Int
  use prelude.Bool
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use mach.int.UInt32
  use prelude.Int16
  type newclonestest_counter_closure0  =
    | NewClonesTest_Counter_Closure0
    
  predicate precondition [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (self : newclonestest_counter_closure0) (args : (uint32, Ghost.ghost_ty (Seq.seq uint32)))
    
   =
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] let (x, _prod) = args in true
  predicate unnest [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (self : newclonestest_counter_closure0) (_2' : newclonestest_counter_closure0)
    
   =
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] true
  predicate postcondition_mut [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (self : borrowed newclonestest_counter_closure0) (args : (uint32, Ghost.ghost_ty (Seq.seq uint32))) (result' : uint32)
    
   =
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] (let (x, _prod) = args in true) /\ unnest ( * self) ( ^ self)
  predicate postcondition_once [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (self : newclonestest_counter_closure0) (args : (uint32, Ghost.ghost_ty (Seq.seq uint32))) (result' : uint32)
    
   =
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] let (x, _prod) = args in true
  predicate resolve [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (_1' : newclonestest_counter_closure0)
    
   =
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] true
  val newClonesTest_Counter_Closure0 [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (_1' : borrowed newclonestest_counter_closure0) (x : uint32) (_prod : Ghost.ghost_ty (Seq.seq uint32)) : uint32
    
end
module NewClonesTest_Counter_Closure0
  use prelude.Opaque
  use mach.int.Int
  use prelude.Bool
  use prelude.Borrow
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use mach.int.UInt32
  use prelude.Int16
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = newclonestest_counter_closure0
  type newclonestest_counter_closure0  =
    | NewClonesTest_Counter_Closure0
    
  predicate precondition [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (self : newclonestest_counter_closure0) (args : (uint32, Ghost.ghost_ty (Seq.seq uint32)))
    
   =
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] let (x, _prod) = args in true
  predicate unnest [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (self : newclonestest_counter_closure0) (_2' : newclonestest_counter_closure0)
    
   =
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] true
  predicate postcondition_mut [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (self : borrowed newclonestest_counter_closure0) (args : (uint32, Ghost.ghost_ty (Seq.seq uint32))) (result' : uint32)
    
   =
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] (let (x, _prod) = args in true) /\ unnest ( * self) ( ^ self)
  predicate postcondition_once [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (self : newclonestest_counter_closure0) (args : (uint32, Ghost.ghost_ty (Seq.seq uint32))) (result' : uint32)
    
   =
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] let (x, _prod) = args in true
  predicate resolve [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (_1' : newclonestest_counter_closure0)
    
   =
    [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 1 0 1 0] true
  let rec cfg newClonesTest_Counter_Closure0 [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 39 5 49] (_1' : borrowed newclonestest_counter_closure0) (x : uint32) (_prod : Ghost.ghost_ty (Seq.seq uint32)) : uint32
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint32;
  var _1 : borrowed newclonestest_counter_closure0;
  var x_2 : uint32;
  var _prod_3 : Ghost.ghost_ty (Seq.seq uint32);
  {
    _1 <- _1';
    x_2 <- x;
    _prod_3 <- _prod;
    goto BB0
  }
  BB0 {
    _0 <- ([#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 50 5 51] (0 : uint32));
    assume { Resolve2.resolve _1 };
    return _0
  }
  
end
module CreusotContracts_Std1_Iter_MapInv_Impl0_Produces_Stub
  type i
  type b
  type f
  use mach.int.Int
  use seq.Seq
  use prelude.Bool
  use prelude.Borrow
  use seq.Seq
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Ghost
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  predicate produces [@inline:trivial] (self : CMapInv1.t_mapinv i Item1.item f) (visited : Seq.seq b) (succ : CMapInv1.t_mapinv i Item1.item f)
    
end
module CreusotContracts_Std1_Iter_MapInv_Impl0_Produces
  type i
  type b
  type f
  use prelude.Opaque
  use mach.int.Int
  use Core_Marker_PhantomData_Type as CPhantomData1
  use seq.Seq
  use seq.Seq
  use prelude.Bool
  use prelude.Borrow
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use seq_ext.SeqExt
  use Core_Marker_PhantomData_Type as CPhantomData3
  use prelude.Ghost
  use prelude.Ghost
  use seq.Seq
  use Core_Marker_PhantomData_Type as CPhantomData4
  use seq.Seq
  use seq.Seq
  use seq.Seq
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Ghost
  use seq.Seq
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Ops_Impl1_PostconditionMut_Stub as PostconditionMut1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Ops_Impl0_Precondition_Stub as Precondition1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces1 with
    type self = i,
    type Item0.item = Item1.item
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Ops_Impl1_Unnest_Stub as Unnest1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  predicate produces [@inline:trivial] (self : CMapInv1.t_mapinv i Item1.item f) (visited : Seq.seq b) (succ : CMapInv1.t_mapinv i Item1.item f)
    
   =
    Unnest1.unnest (FieldFunc1.field_func self) (FieldFunc1.field_func succ) /\ (exists s : Seq.seq Item1.item . Seq.length s = Seq.length visited /\ Produces1.produces (FieldIter1.field_iter self) s (FieldIter1.field_iter succ) /\ Ghost.inner (FieldProduced1.field_produced succ) = Seq.(++) (Ghost.inner (FieldProduced1.field_produced self)) s /\ (exists fs : Seq.seq (borrowed f) . Seq.length fs = Seq.length visited /\ (forall i : int . 1 <= i /\ i < Seq.length fs ->  ^ Seq.get fs (i - 1) =  * Seq.get fs i) /\ (if Seq.length visited = 0 then
      FieldFunc1.field_func self = FieldFunc1.field_func succ
    else
       * Seq.get fs 0 = FieldFunc1.field_func self /\  ^ Seq.get fs (Seq.length visited - 1) = FieldFunc1.field_func succ
    ) /\ (forall i : int . 0 <= i /\ i < Seq.length visited -> Unnest1.unnest (FieldFunc1.field_func self) ( * Seq.get fs i) /\ Precondition1.precondition ( * Seq.get fs i) (Seq.get s i, Ghost.new (Seq.(++) (Ghost.inner (FieldProduced1.field_produced self)) (SeqExt.subsequence s 0 i))) /\ PostconditionMut1.postcondition_mut (Seq.get fs i) (Seq.get s i, Ghost.new (Seq.(++) (Ghost.inner (FieldProduced1.field_produced self)) (SeqExt.subsequence s 0 i))) (Seq.get visited i))))
  val produces [@inline:trivial] (self : CMapInv1.t_mapinv i Item1.item f) (visited : Seq.seq b) (succ : CMapInv1.t_mapinv i Item1.item f) : bool
    ensures { result = produces self visited succ }
    
end
module CreusotContracts_Std1_Iter_Iterator_Completed_Stub
  type self
  use prelude.Bool
  use prelude.Borrow
  predicate completed (self : borrowed self)
end
module CreusotContracts_Std1_Iter_Iterator_Completed
  type self
  use prelude.Bool
  use prelude.Borrow
  predicate completed (self : borrowed self)
  val completed (self : borrowed self) : bool
    ensures { result = completed self }
    
end
module CreusotContracts_Logic_Seq_Impl0_Empty_Stub
  type t
  use seq.Seq
  val constant eMPTY'  : Seq.seq t
end
module CreusotContracts_Logic_Seq_Impl0_Empty
  use Core_Marker_PhantomData_Type as CPhantomData0
  use seq.Seq
  let constant eMPTY'  : Seq.seq t = [@vc:do_not_keep_trace] [@vc:sp]
    ()
end
module CreusotContracts_Std1_Iter_MapInv_Impl0_Completed_Stub
  type i
  type b
  type f
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Bool
  use prelude.Borrow
  use seq.Seq
  use mach.int.Int
  use prelude.Borrow
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  predicate completed (self : borrowed (CMapInv1.t_mapinv i Item1.item f))
end
module CreusotContracts_Std1_Iter_MapInv_Impl0_Completed
  type i
  type b
  type f
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Bool
  use prelude.Borrow
  use seq.Seq
  use prelude.Ghost
  use prelude.Opaque
  use mach.int.Int
  use prelude.Borrow
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_Iterator_Completed_Stub as Completed1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  predicate completed (self : borrowed (CMapInv1.t_mapinv i Item1.item f)) =
    Ghost.inner (FieldProduced1.field_produced ( ^ self)) = Seq.empty  /\ Completed1.completed {current = FieldIter1.field_iter ( * self); final = FieldIter1.field_iter ( ^ self)} /\ FieldFunc1.field_func ( * self) = FieldFunc1.field_func ( ^ self)
  val completed (self : borrowed (CMapInv1.t_mapinv i Item1.item f)) : bool
    ensures { result = completed self }
    
end
module CreusotContracts_Model_Impl3_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy1 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy1.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy1 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel1 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy1.shallowModelTy =
    ShallowModel1.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy1.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_Impl15_Completed_Stub
  type t
  use seq.Seq
  use Core_Slice_Iter_Iter_Type as CIter0
  use prelude.Borrow
  use prelude.Borrow
  use prelude.UIntSize
  use prelude.Bool
  use prelude.Slice
  use mach.int.Int
  use mach.int.UInt64
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl13_ShallowModel_Stub as ShallowModel1 with
    type t = t
  clone Core_Num_Impl12_Max_Stub as MAx0
  predicate completed (self : borrowed (CIter0.t_iter t))
end
module CreusotContracts_Std1_Slice_Impl15_Completed
  type t
  use Core_Marker_PhantomData_Type as CPhantomData1
  use seq.Seq
  use seq.Seq
  use Core_Marker_PhantomData_Type as CPhantomData2
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull1
  use Core_Slice_Iter_Iter_Type as CIter0
  use prelude.Borrow
  use prelude.Borrow
  use prelude.UIntSize
  use prelude.Bool
  use prelude.Slice
  use prelude.Opaque
  use mach.int.Int
  use mach.int.UInt64
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl13_ShallowModel_Stub as ShallowModel1 with
    type t = t
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel4 with
    type t = CIter0.t_iter t,
    type ShallowModelTy1.shallowModelTy = seq t
  clone Core_Num_Impl12_Max_Stub as MAx0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel7 with
    type t = t
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve1 with
    type t = CIter0.t_iter t
  predicate completed (self : borrowed (CIter0.t_iter t)) =
    Resolve1.resolve self /\ ShallowModel7.shallow_model (ShallowModel4.shallow_model self) = Seq.empty 
  val completed (self : borrowed (CIter0.t_iter t)) : bool
    ensures { result = completed self }
    
end
module CreusotContracts_Std1_Iter_MapInv_Impl4_Resolve_Stub
  type i
  type b
  type f
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv0
  use prelude.Bool
  use mach.int.Int
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc0 with
    type i = i,
    type b = b,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter0 with
    type i = i,
    type b = b,
    type f = f
  predicate resolve (self : CMapInv0.t_mapinv i b f)
end
module CreusotContracts_Std1_Iter_MapInv_Impl4_Resolve
  type i
  type b
  type f
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv0
  use prelude.Bool
  use prelude.Opaque
  use mach.int.Int
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc0 with
    type i = i,
    type b = b,
    type f = f
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter0 with
    type i = i,
    type b = b,
    type f = f
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve2 with
    type self = i
  predicate resolve (self : CMapInv0.t_mapinv i b f) =
    Resolve2.resolve (FieldIter0.field_iter self) /\ Resolve1.resolve (FieldFunc0.field_func self)
  val resolve (self : CMapInv0.t_mapinv i b f) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Logic_Seq_Impl0_Singleton_Stub
  type t
  use seq.Seq
  function singleton (_1' : t) : Seq.seq t
end
module CreusotContracts_Logic_Seq_Impl0_Singleton
  type t
  use seq.Seq
  use seq.Seq
  function singleton (_1' : t) : Seq.seq t =
    Seq.singleton _1'
  val singleton (_1' : t) : Seq.seq t
    ensures { result = singleton _1' }
    
end
module CreusotContracts_Invariant_Invariant_Invariant_Stub
  type self
  use prelude.Bool
  predicate invariant' (self : self)
end
module CreusotContracts_Invariant_Invariant_Invariant
  type self
  use prelude.Bool
  predicate invariant' (self : self)
  val invariant' (self : self) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Std1_Iter_MapInv_Impl3_NextPrecondition_Stub
  type i
  type b
  type f
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Bool
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  predicate next_precondition (self : CMapInv1.t_mapinv i Item1.item f)
end
module CreusotContracts_Std1_Iter_MapInv_Impl3_NextPrecondition
  type i
  type b
  type f
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Bool
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Ops_Impl0_Precondition_Stub as Precondition1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces1 with
    type self = i,
    type Item0.item = Item1.item
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant1 with
    type self = i
  predicate next_precondition (self : CMapInv1.t_mapinv i Item1.item f) =
    forall i : i . forall e : Item1.item . Invariant1.invariant' i -> Produces1.produces (FieldIter1.field_iter self) (Seq.singleton e) i -> Precondition1.precondition (FieldFunc1.field_func self) (e, FieldProduced1.field_produced self)
  val next_precondition (self : CMapInv1.t_mapinv i Item1.item f) : bool
    ensures { result = next_precondition self }
    
end
module CreusotContracts_Logic_Seq_Impl0_Push_Stub
  type t
  use seq.Seq
  function push (self : Seq.seq t) (_2' : t) : Seq.seq t
end
module CreusotContracts_Logic_Seq_Impl0_Push
  type t
  use seq.Seq
  use seq.Seq
  function push (self : Seq.seq t) (_2' : t) : Seq.seq t =
    Seq.snoc self _2'
  val push (self : Seq.seq t) (_2' : t) : Seq.seq t
    ensures { result = push self _2' }
    
end
module CreusotContracts_Std1_Iter_MapInv_Impl3_Preservation_Stub
  type i
  type b
  type f
  use prelude.Bool
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  predicate preservation (iter : i) (func : f)
end
module CreusotContracts_Std1_Iter_MapInv_Impl3_Preservation
  type i
  type b
  type f
  use prelude.Bool
  use prelude.Borrow
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Ops_Impl1_PostconditionMut_Stub as PostconditionMut1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Ops_Impl0_Precondition_Stub as Precondition1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces1 with
    type self = i,
    type Item0.item = Item1.item
  clone CreusotContracts_Std1_Ops_Impl1_Unnest_Stub as Unnest1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant1 with
    type self = i
  predicate preservation (iter : i) (func : f) =
    forall i : i . forall b : b . forall f : borrowed f . forall e2 : Item1.item . forall e1 : Item1.item . forall s : Seq.seq Item1.item . Invariant1.invariant' i -> Unnest1.unnest func ( * f) -> Produces1.produces iter (Seq.snoc (Seq.snoc s e1) e2) i -> Precondition1.precondition ( * f) (e1, Ghost.new s) -> PostconditionMut1.postcondition_mut f (e1, Ghost.new s) b -> Precondition1.precondition ( ^ f) (e2, Ghost.new (Seq.snoc s e1))
  val preservation (iter : i) (func : f) : bool
    ensures { result = preservation iter func }
    
end
module CreusotContracts_Std1_Iter_MapInv_Impl3_PreservationInv_Stub
  type i
  type b
  type f
  use prelude.Bool
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use seq.Seq
  use prelude.Ghost
  use mach.int.Int
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Preservation_Stub as Preservation0 with
    type i = i,
    type b = b,
    type f = f,
    type Item1.item = Item1.item
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  predicate preservation_inv (self : CMapInv1.t_mapinv i Item1.item f)
end
module CreusotContracts_Std1_Iter_MapInv_Impl3_PreservationInv
  type i
  type b
  type f
  use prelude.Bool
  use prelude.Borrow
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use seq.Seq
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use seq.Seq
  use prelude.Ghost
  use prelude.Opaque
  use mach.int.Int
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Ops_Impl1_PostconditionMut_Stub as PostconditionMut1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Ops_Impl0_Precondition_Stub as Precondition1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces1 with
    type self = i,
    type Item0.item = Item1.item
  clone CreusotContracts_Std1_Ops_Impl1_Unnest_Stub as Unnest1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Preservation_Stub as Preservation0 with
    type i = i,
    type b = b,
    type f = f,
    type Item1.item = Item1.item
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  predicate preservation_inv (self : CMapInv1.t_mapinv i Item1.item f) =
    forall i : i . forall b : b . forall f : borrowed f . forall e2 : Item1.item . forall e1 : Item1.item . forall s : Seq.seq Item1.item . Invariant1.invariant' i -> Unnest1.unnest (FieldFunc1.field_func self) ( * f) -> Produces1.produces (FieldIter1.field_iter self) (Seq.snoc (Seq.snoc s e1) e2) i -> Precondition1.precondition ( * f) (e1, Ghost.new (Seq.(++) (Ghost.inner (FieldProduced1.field_produced self)) s)) -> PostconditionMut1.postcondition_mut f (e1, Ghost.new (Seq.(++) (Ghost.inner (FieldProduced1.field_produced self)) s)) b -> Precondition1.precondition ( ^ f) (e2, Ghost.new (Seq.snoc (Seq.(++) (Ghost.inner (FieldProduced1.field_produced self)) s) e1))
  val preservation_inv (self : CMapInv1.t_mapinv i Item1.item f) : bool
    ensures { result = preservation_inv self }
    
  axiom preservation_inv_spec : forall self : CMapInv1.t_mapinv i Item1.item f . Ghost.inner (FieldProduced1.field_produced self) = Seq.empty  -> preservation_inv self = Preservation0.preservation (FieldIter1.field_iter self) (FieldFunc1.field_func self)
end
module CreusotContracts_Std1_Iter_MapInv_Impl3_Reinitialize_Stub
  type i
  type b
  type f
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Bool
  use prelude.Borrow
  use mach.int.Int
  use prelude.Borrow
  use seq.Seq
  use prelude.Borrow
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Preservation_Stub as Preservation0 with
    type i = i,
    type b = b,
    type f = f,
    type Item1.item = Item1.item
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  predicate reinitialize (_1' : ())
end
module CreusotContracts_Std1_Iter_MapInv_Impl3_Reinitialize
  type i
  type b
  type f
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Bool
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use seq.Seq
  use prelude.Opaque
  use mach.int.Int
  use prelude.Borrow
  use seq.Seq
  use prelude.Ghost
  use prelude.Borrow
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Ops_Impl1_PostconditionMut_Stub as PostconditionMut1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Ops_Impl0_Precondition_Stub as Precondition1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces1 with
    type self = i,
    type Item0.item = Item1.item
  clone CreusotContracts_Std1_Ops_Impl1_Unnest_Stub as Unnest1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Preservation_Stub as Preservation0 with
    type i = i,
    type b = b,
    type f = f,
    type Item1.item = Item1.item
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_NextPrecondition_Stub as NextPrecondition0 with
    type i = i,
    type b = b,
    type f = f,
    type Item1.item = Item1.item
  clone CreusotContracts_Std1_Iter_Iterator_Completed_Stub as Completed1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_Impl0_Completed_Stub as Completed2 with
    type i = i,
    type b = b,
    type f = f,
    type Item1.item = Item1.item
  predicate reinitialize (_1' : ()) =
    forall reset : borrowed (CMapInv1.t_mapinv i Item1.item f) . Completed2.completed reset -> Invariant1.invariant' (FieldIter1.field_iter ( ^ reset)) -> NextPrecondition0.next_precondition ( ^ reset) /\ Preservation0.preservation (FieldIter1.field_iter ( ^ reset)) (FieldFunc1.field_func ( ^ reset))
  val reinitialize (_1' : ()) : bool
    ensures { result = reinitialize _1' }
    
end
module CreusotContracts_Std1_Iter_MapInv_Impl1_Invariant_Stub
  type i
  type b
  type f
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Bool
  use prelude.Borrow
  use seq.Seq
  use prelude.Ghost
  use mach.int.Int
  use prelude.Borrow
  use prelude.Borrow
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Preservation_Stub as Preservation0 with
    type i = i,
    type b = b,
    type f = f,
    type Item1.item = Item1.item
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Reinitialize_Stub as Reinitialize0 with
    type i = i,
    type b = b,
    type f = f
  predicate invariant' (self : CMapInv1.t_mapinv i Item1.item f)
end
module CreusotContracts_Std1_Iter_MapInv_Impl1_Invariant
  type i
  type b
  type f
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Ghost
  use Core_Marker_PhantomData_Type as CPhantomData2
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Bool
  use seq.Seq
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use prelude.Ghost
  use seq.Seq
  use seq.Seq
  use prelude.Ghost
  use prelude.Opaque
  use mach.int.Int
  use prelude.Borrow
  use prelude.Borrow
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Ops_Impl0_Precondition_Stub as Precondition1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = i,
    type b = Item1.item,
    type f = f
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces1 with
    type self = i,
    type Item0.item = Item1.item
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_NextPrecondition_Stub as NextPrecondition0 with
    type i = i,
    type b = b,
    type f = f,
    type Item1.item = Item1.item
  clone CreusotContracts_Std1_Ops_Impl1_PostconditionMut_Stub as PostconditionMut1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Ops_Impl1_Unnest_Stub as Unnest1 with
    type args = (Item1.item, Ghost.ghost_ty (Seq.seq Item1.item)),
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Preservation_Stub as Preservation0 with
    type i = i,
    type b = b,
    type f = f,
    type Item1.item = Item1.item
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_PreservationInv_Stub as PreservationInv0 with
    type i = i,
    type b = b,
    type f = f,
    type Item1.item = Item1.item
  clone CreusotContracts_Std1_Iter_Iterator_Completed_Stub as Completed1 with
    type self = i
  clone CreusotContracts_Std1_Iter_MapInv_Impl0_Completed_Stub as Completed2 with
    type i = i,
    type b = b,
    type f = f,
    type Item1.item = Item1.item
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Reinitialize_Stub as Reinitialize0 with
    type i = i,
    type b = b,
    type f = f
  predicate invariant' (self : CMapInv1.t_mapinv i Item1.item f) =
    Reinitialize0.reinitialize () /\ PreservationInv0.preservation_inv self /\ Invariant1.invariant' (FieldIter1.field_iter self) /\ NextPrecondition0.next_precondition self
  val invariant' (self : CMapInv1.t_mapinv i Item1.item f) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Std1_Slice_Impl14_Invariant_Stub
  type t
  use prelude.Bool
  use Core_Slice_Iter_Iter_Type as CIter0
  predicate invariant' (self : CIter0.t_iter t)
end
module CreusotContracts_Std1_Slice_Impl14_Invariant
  type t
  use prelude.Bool
  use Core_Marker_PhantomData_Type as CPhantomData1
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull1
  use Core_Slice_Iter_Iter_Type as CIter0
  predicate invariant' (self : CIter0.t_iter t) =
    true
  val invariant' (self : CIter0.t_iter t) : bool
    ensures { result = invariant' self }
    
end
module Core_Iter_Traits_Iterator_Iterator_Collect_Stub
  type self
  type b
  use prelude.Borrow
  use seq.Seq
  use prelude.Bool
  use mach.int.Int
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  clone CreusotContracts_Std1_Iter_FromIterator_FromIterPost_Stub as FromIterPost1 with
    type self = b,
    type a = Item0.item
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces0 with
    type self = self,
    type Item0.item = Item0.item
  clone CreusotContracts_Std1_Iter_Iterator_Completed_Stub as Completed0 with
    type self = self
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = self
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = self
  val collect [@cfg:stackify] (self : self) : b
    requires {Invariant0.invariant' self}
    ensures { exists prod : Seq.seq Item0.item . exists done_ : borrowed self . Resolve0.resolve ( ^ done_) /\ Completed0.completed done_ /\ Produces0.produces self prod ( * done_) /\ FromIterPost1.from_iter_post prod result }
    
end
module CreusotContracts_Std1_Iter_Iterator_MapInv_Stub
  type self
  type b
  type f
  use prelude.Bool
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use mach.int.Int
  use seq.Seq
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use prelude.Ghost
  use prelude.Borrow
  use prelude.Borrow
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = self,
    type b = Item0.item,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = self,
    type b = Item0.item,
    type f = f
  clone CreusotContracts_Std1_Ops_Impl0_Precondition_Stub as Precondition1 with
    type args = (Item0.item, Ghost.ghost_ty (Seq.seq Item0.item)),
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = self,
    type b = Item0.item,
    type f = f
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces0 with
    type self = self,
    type Item0.item = Item0.item
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = self
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Preservation_Stub as Preservation1 with
    type i = self,
    type b = b,
    type f = f,
    type Item1.item = Item0.item
  clone CreusotContracts_Std1_Iter_Iterator_Completed_Stub as Completed0 with
    type self = self
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Reinitialize_Stub as Reinitialize1 with
    type i = self,
    type b = b,
    type f = f
  clone CreusotContracts_Std1_Iter_MapInv_Impl1_Invariant_Stub as Invariant3 with
    type i = self,
    type b = b,
    type f = f,
    type Item1.item = Item0.item
  val map_inv [@cfg:stackify] (self : self) (func : f) : CMapInv1.t_mapinv self Item0.item f
    requires {forall i2 : self . forall e : Item0.item . Invariant0.invariant' i2 -> Produces0.produces self (Seq.singleton e) i2 -> Precondition1.precondition func (e, Ghost.new (Seq.empty ))}
    requires {Reinitialize1.reinitialize ()}
    requires {Preservation1.preservation self func}
    requires {Invariant0.invariant' self}
    ensures { Invariant3.invariant' result }
    ensures { result = CMapInv1.C_MapInv self func (Ghost.new (Seq.empty )) }
    
end
module Core_Slice_Impl0_Iter_Stub
  type t
  use prelude.Bool
  use Core_Slice_Iter_Iter_Type as CIter1
  use mach.int.Int
  clone CreusotContracts_Std1_Slice_Impl14_Invariant_Stub as Invariant1 with
    type t = t
  clone CreusotContracts_Std1_Slice_Impl13_ShallowModel_Stub as ShallowModel2 with
    type t = t
  val iter [@cfg:stackify] (self : seq t) : CIter1.t_iter t
    ensures { ShallowModel2.shallow_model result = self }
    ensures { Invariant1.invariant' result }
    
end
module Alloc_Vec_Impl10_Deref_Stub
  type t
  type a
  use seq.Seq
  use prelude.Bool
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type as CVec0
  use mach.int.Int
  use mach.int.UInt64
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl12_Max_Stub as MAx0
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel5 with
    type t = CVec0.t_vec t a,
    type ShallowModelTy1.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel7 with
    type t = seq t,
    type ShallowModelTy1.shallowModelTy = Seq.seq t
  val deref [@cfg:stackify] (self : CVec0.t_vec t a) : seq t
    ensures { ShallowModel7.shallow_model result = ShallowModel5.shallow_model self }
    
end
module NewClonesTest_Counter_Stub
  use mach.int.Int
  use seq.Seq
  use seq.Seq
  use prelude.Bool
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type as CVec1
  use mach.int.UInt64
  use seq.Seq
  use Alloc_Alloc_Global_Type as CGlobal0
  use prelude.Borrow
  use mach.int.UInt32
  use seq.Seq
  use prelude.Ghost
  use prelude.Ghost
  use seq.Seq
  use seq.Seq
  use prelude.Borrow
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Ghost
  use Core_Slice_Iter_Iter_Type as CIter1
  use prelude.Slice
  use seq.Seq
  use prelude.Int16
  use prelude.Borrow
  use prelude.Borrow
  use prelude.Borrow
  use seq.Seq
  use prelude.Borrow
  use seq.Seq
  clone Core_Num_Impl12_Max_Stub as MAx0
  clone CreusotContracts_Std1_Vec_Impl8_FromIterPost_Stub as FromIterPost1 with
    type t = uint32
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced_Stub as FieldProduced1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter_Stub as FieldIter1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0
  clone CreusotContracts_Std1_Slice_Impl13_ShallowModel_Stub as ShallowModel6 with
    type t = uint32
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel11 with
    type t = seq uint32,
    type ShallowModelTy1.shallowModelTy = Seq.seq uint32
  clone CreusotContracts_Std1_Slice_Impl15_Produces_Stub as Produces1 with
    type t = uint32
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func_Stub as FieldFunc1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0
  clone NewClonesTest_Counter_Closure0_Stub as Closure00
  clone CreusotContracts_Std1_Iter_MapInv_Impl0_Produces_Stub as Produces2 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    type Item1.item = uint32
  clone CreusotContracts_Std1_Iter_MapInv_Impl0_Completed_Stub as Completed4 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    type Item1.item = uint32
  clone CreusotContracts_Std1_Iter_MapInv_Impl4_Resolve_Stub as Resolve9 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0
  clone CreusotContracts_Std1_Slice_Impl14_Invariant_Stub as Invariant4 with
    type t = uint32
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Preservation_Stub as Preservation1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    type Item1.item = uint32
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Reinitialize_Stub as Reinitialize1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0
  clone CreusotContracts_Std1_Iter_MapInv_Impl1_Invariant_Stub as Invariant5 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    type Item1.item = uint32
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel16 with
    type t = CVec1.t_vec uint32 (CGlobal0.t_global),
    type ShallowModelTy1.shallowModelTy = Seq.seq uint32
  val counter [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 4 0 4 27] (v : CVec1.t_vec uint32 (CGlobal0.t_global)) : ()
    
end
module NewClonesTest_Counter
  use prelude.Opaque
  use mach.int.Int
  use Core_Marker_PhantomData_Type as CPhantomData1
  use seq.Seq
  use seq.Seq
  use prelude.Bool
  use prelude.UIntSize
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as CNonNull1
  use Core_Ptr_Unique_Unique_Type as CUnique1
  use Alloc_RawVec_RawVec_Type as CRawVec1
  use Alloc_Vec_Vec_Type as CVec1
  use mach.int.UInt64
  use seq.Seq
  use Alloc_Alloc_Global_Type as CGlobal0
  use prelude.Borrow
  use mach.int.UInt32
  use Core_Marker_PhantomData_Type as CPhantomData3
  use seq.Seq
  use seq_ext.SeqExt
  use Core_Marker_PhantomData_Type as CPhantomData4
  use prelude.Ghost
  use prelude.Ghost
  use seq.Seq
  use Core_Marker_PhantomData_Type as CPhantomData5
  use seq.Seq
  use seq.Seq
  use seq.Seq
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use CreusotContracts_Std1_Iter_MapInv_MapInv_Type as CMapInv1
  use prelude.Ghost
  use Core_Slice_Iter_Iter_Type as CIter1
  use prelude.Slice
  use seq.Seq
  use prelude.Int16
  use prelude.Borrow
  use seq.Seq
  use prelude.Borrow
  use prelude.Borrow
  use seq.Seq
  use prelude.Borrow
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint32
  clone Core_Num_Impl12_Max as MAx0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel3 with
    type t = uint32,
    type a = CGlobal0.t_global,
    val MAx0.mAX' = MAx0.mAX'
  clone CreusotContracts_Std1_Vec_Impl9_Resolve as Resolve4 with
    type t = uint32,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model,
    predicate Resolve1.resolve = Resolve1.resolve
  clone CreusotContracts_Std1_Vec_Impl8_FromIterPost as FromIterPost1 with
    type t = uint32,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Produced as FieldProduced1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Iter as FieldIter1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0
  clone CreusotContracts_Std1_Slice_Impl13_ShallowModel as ShallowModel6 with
    type t = uint32
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel8 with
    type t = uint32,
    val MAx0.mAX' = MAx0.mAX'
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel11 with
    type t = seq uint32,
    type ShallowModelTy1.shallowModelTy = Seq.seq uint32,
    function ShallowModel1.shallow_model = ShallowModel8.shallow_model
  clone CreusotContracts_Std1_Slice_Impl4_ToRefSeq as ToRefSeq1 with
    type t = uint32,
    function ShallowModel5.shallow_model = ShallowModel11.shallow_model
  clone CreusotContracts_Std1_Slice_Impl15_Produces as Produces1 with
    type t = uint32,
    function ToRefSeq1.to_ref_seq = ToRefSeq1.to_ref_seq,
    function ShallowModel1.shallow_model = ShallowModel6.shallow_model
  clone CreusotContracts_Std1_Iter_MapInv_MapInv_Func as FieldFunc1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve6 with
    type t = Closure00.newclonestest_counter_closure0
  clone NewClonesTest_Counter_Closure0_Stub as Closure00 with
    predicate Resolve2.resolve = Resolve6.resolve
  clone CreusotContracts_Std1_Iter_MapInv_Impl0_Produces as Produces2 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    type Item1.item = uint32,
    predicate Unnest1.unnest = Closure00.newClonesTest_Counter_Closure0,
    val FieldFunc1.field_func = FieldFunc1.field_func,
    predicate Produces1.produces = Produces1.produces,
    val FieldIter1.field_iter = FieldIter1.field_iter,
    val FieldProduced1.field_produced = FieldProduced1.field_produced
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel14 with
    type t = CIter1.t_iter uint32,
    type ShallowModelTy1.shallowModelTy = seq uint32,
    function ShallowModel1.shallow_model = ShallowModel6.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve7 with
    type t = CIter1.t_iter uint32
  clone CreusotContracts_Std1_Slice_Impl15_Completed as Completed3 with
    type t = uint32,
    predicate Resolve1.resolve = Resolve7.resolve,
    function ShallowModel7.shallow_model = ShallowModel8.shallow_model,
    function ShallowModel4.shallow_model = ShallowModel14.shallow_model
  clone CreusotContracts_Std1_Iter_MapInv_Impl0_Completed as Completed4 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    type Item1.item = uint32,
    val FieldProduced1.field_produced = FieldProduced1.field_produced,
    predicate Completed1.completed = Completed3.completed,
    val FieldIter1.field_iter = FieldIter1.field_iter,
    val FieldFunc1.field_func = FieldFunc1.field_func
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve8 with
    type t = CIter1.t_iter uint32
  clone CreusotContracts_Std1_Iter_MapInv_Impl4_Resolve as Resolve9 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    predicate Resolve2.resolve = Resolve8.resolve,
    val FieldIter0.field_iter = FieldIter1.field_iter,
    predicate Resolve1.resolve = Closure00.newClonesTest_Counter_Closure0,
    val FieldFunc0.field_func = FieldFunc1.field_func
  clone CreusotContracts_Std1_Slice_Impl14_Invariant as Invariant4 with
    type t = uint32
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_NextPrecondition as NextPrecondition1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    type Item1.item = uint32,
    predicate Invariant1.invariant' = Invariant4.invariant',
    predicate Produces1.produces = Produces1.produces,
    val FieldIter1.field_iter = FieldIter1.field_iter,
    predicate Precondition1.precondition = Closure00.newClonesTest_Counter_Closure0,
    val FieldFunc1.field_func = FieldFunc1.field_func,
    val FieldProduced1.field_produced = FieldProduced1.field_produced
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Preservation as Preservation1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    predicate Invariant1.invariant' = Invariant4.invariant',
    type Item1.item = uint32,
    predicate Unnest1.unnest = Closure00.newClonesTest_Counter_Closure0,
    predicate Produces1.produces = Produces1.produces
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_PreservationInv as PreservationInv1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    type Item1.item = uint32,
    val FieldProduced1.field_produced = FieldProduced1.field_produced,
    predicate Preservation0.preservation = Preservation1.preservation,
    val FieldIter1.field_iter = FieldIter1.field_iter,
    val FieldFunc1.field_func = FieldFunc1.field_func,
    predicate Invariant1.invariant' = Invariant4.invariant',
    predicate Unnest1.unnest = Closure00.newClonesTest_Counter_Closure0,
    predicate Produces1.produces = Produces1.produces
  clone CreusotContracts_Std1_Iter_MapInv_Impl3_Reinitialize as Reinitialize1 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    predicate Completed2.completed = Completed4.completed,
    predicate Invariant1.invariant' = Invariant4.invariant',
    val FieldIter1.field_iter = FieldIter1.field_iter,
    predicate NextPrecondition0.next_precondition = NextPrecondition1.next_precondition,
    predicate Preservation0.preservation = Preservation1.preservation,
    val FieldFunc1.field_func = FieldFunc1.field_func
  clone CreusotContracts_Std1_Iter_MapInv_Impl1_Invariant as Invariant5 with
    type i = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    type Item1.item = uint32,
    predicate Reinitialize0.reinitialize = Reinitialize1.reinitialize,
    predicate PreservationInv0.preservation_inv = PreservationInv1.preservation_inv,
    predicate Invariant1.invariant' = Invariant4.invariant',
    val FieldIter1.field_iter = FieldIter1.field_iter,
    predicate NextPrecondition0.next_precondition = NextPrecondition1.next_precondition
  clone Core_Iter_Traits_Iterator_Iterator_Collect_Stub as Collect1 with
    type self = CMapInv1.t_mapinv (CIter1.t_iter uint32) uint32 Closure00.newclonestest_counter_closure0,
    type b = CVec1.t_vec uint32 (CGlobal0.t_global),
    predicate Invariant0.invariant' = Invariant5.invariant',
    predicate Resolve0.resolve = Resolve9.resolve,
    predicate Completed0.completed = Completed4.completed,
    predicate Produces0.produces = Produces2.produces,
    type Item0.item = uint32,
    predicate FromIterPost1.from_iter_post = FromIterPost1.from_iter_post
  clone CreusotContracts_Std1_Iter_Iterator_MapInv_Stub as MapInv1 with
    type self = CIter1.t_iter uint32,
    type b = uint32,
    type f = Closure00.newclonestest_counter_closure0,
    predicate Invariant0.invariant' = Invariant4.invariant',
    predicate Produces0.produces = Produces1.produces,
    type Item0.item = uint32,
    predicate Precondition1.precondition = Closure00.newClonesTest_Counter_Closure0,
    predicate Reinitialize1.reinitialize = Reinitialize1.reinitialize,
    predicate Preservation1.preservation = Preservation1.preservation,
    predicate Invariant3.invariant' = Invariant5.invariant'
  clone Core_Slice_Impl0_Iter_Stub as Iter1 with
    type t = uint32,
    function ShallowModel2.shallow_model = ShallowModel6.shallow_model,
    predicate Invariant1.invariant' = Invariant4.invariant'
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel16 with
    type t = CVec1.t_vec uint32 (CGlobal0.t_global),
    type ShallowModelTy1.shallowModelTy = Seq.seq uint32,
    function ShallowModel1.shallow_model = ShallowModel3.shallow_model
  clone Alloc_Vec_Impl10_Deref_Stub as Deref5 with
    type t = uint32,
    type a = CGlobal0.t_global,
    function ShallowModel7.shallow_model = ShallowModel11.shallow_model,
    function ShallowModel5.shallow_model = ShallowModel16.shallow_model
  let rec cfg counter [@cfg:stackify] [#"..//Users/xavier/Code/creusot/new_clones_test.rs" 4 0 4 27] (v : CVec1.t_vec uint32 (CGlobal0.t_global)) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var v_1 : CVec1.t_vec uint32 (CGlobal0.t_global);
  var x_2 : CVec1.t_vec uint32 (CGlobal0.t_global);
  var _3 : CMapInv1.t_mapinv (CIter1.t_iter uint32) uint32 Closure00.newclonestest_counter_closure0;
  var _4 : CIter1.t_iter uint32;
  var _5 : seq uint32;
  var _6 : seq uint32;
  var _7 : CVec1.t_vec uint32 (CGlobal0.t_global);
  var _8 : Closure00.newclonestest_counter_closure0;
  {
    v_1 <- v;
    goto BB0
  }
  BB0 {
    _7 <- v_1;
    _6 <- ([#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 22 5 30] Deref5.deref _7);
    goto BB1
  }
  BB1 {
    _5 <- _6;
    _4 <- ([#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 22 5 30] Iter1.iter _5);
    goto BB2
  }
  BB2 {
    _8 <- Closure00.NewClonesTest_Counter_Closure0;
    _3 <- ([#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 22 5 52] MapInv1.map_inv _4 _8);
    goto BB3
  }
  BB3 {
    x_2 <- ([#"..//Users/xavier/Code/creusot/new_clones_test.rs" 5 22 5 62] Collect1.collect _3);
    goto BB4
  }
  BB4 {
    _0 <- ();
    goto BB5
  }
  BB5 {
    assume { Resolve4.resolve x_2 };
    goto BB6
  }
  BB6 {
    assume { Resolve4.resolve v_1 };
    return _0
  }
  
end
